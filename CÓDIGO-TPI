#include <stdio.h>
#define _CRT_RAND_S
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct Respuesta {
    long long Respuesta_Id,Pregunta_Id,Respuesta_Nro;
    char Respuesta[50];
    float Ponderacion; // 0 a 1
    struct Respuesta *sgte;
} Respuesta;

typedef struct Pregunta {
    long long Pregunta_Id,Encuesta_Id;
    char Pregunta[50];
    float Ponderacion; // 0 a 1
    struct Pregunta* sgte;
} Pregunta;

typedef struct Encuesta {
    long long Encuesta_Id,Encuesta_Mes,Encuesta_Anio,Procesada;
    char Denominacion[200];
    struct Encuesta* sgte;
} Encuesta;

typedef struct Marcado {
    long long Pregunta_Id,Respuesta_Id;
    struct Marcado *sgte; // Puntero al siguiente marcado
}Marcado;
Marcado rew,rew2;

typedef struct EncuestaResp {
    long long idEncuestaRespondida, Encuesta_Id,encuestador;
    char fecha[30];
    Marcado* listaPreguntas; // Lista enlazada de respuestas marcadas
    struct EncuestaResp *izq, *der;
}registry;
registry reg2;

//----------------|PUNTEROS FILE|-------------------------
FILE *encuestas_respondidas_CSV,*marcado;

//----------------|PROTOTIPOS|----------------------------
//====|ENCUESTAS|QUINTANA|====
void menuEncuestas(Encuesta **head, Pregunta **headPr, Respuesta **headRe);
void crearEncuesta(Encuesta **head);
void apilar(Encuesta * node, Encuesta **head);
void borrarEncuesta(Encuesta **head, long long id, FILE *listaModificada, Pregunta **headPr, Respuesta **headRe);
void modificarEncuesta(Encuesta **head, long long id, FILE *listaModificada);
void ListaDeEncuestas(Encuesta **head);
int pilavacia(Encuesta *head);
Encuesta * desapilar(Encuesta **head);
void leerCSVencuestas(Encuesta **head);

//====|PREGUNTAS|TARNOWSKI|====
void Crud_Preguntas(Encuesta **tp, Pregunta **l, Respuesta **respL);
void cargarPreguntasDesdeCSV(Pregunta **head);
void crearPregunta(Pregunta **l, Encuesta *e); // 
Pregunta* insertarPregunta(Pregunta *p, Pregunta *r);
void mostrarPregunta(Pregunta *l);
void modificarPregunta(Pregunta **l, long long id, Encuesta *e); //
void borrarPregunta(Pregunta **l, long long encuestaId, Respuesta **res, Encuesta *e); //
void borrarRespuestasPorPreguntaId(Respuesta **l, long long preguntaId);

//====|RESPUESTAS|SANCHEZ|====
void crudRespuestas(Pregunta *pl, Respuesta **l);
void crearRespuesta(Respuesta **l, Pregunta *pl, int uno, long long idPreg);
void insertarRespuesta(Respuesta **l, Respuesta *nv, Respuesta *r);
void mostrarRespuestas(Respuesta *l);
void modificarRespuesta(Respuesta *l, long long id);
void preBorrar(Respuesta **l, long long id, Respuesta *r, Pregunta *pl);
void borrarRespuesta(Respuesta **l, long long id, Respuesta *r);
void leerRespuestasCSV(const char* nombreArchivo, Respuesta **inicio);

//====|ARBOL|AQUINO|====
void Agregar_Registro_Encuesta_Respondida();
registry* insertar_arbol(registry *, registry * );
void mostrar_arbol(registry *);
void Leer_CSV_Encuestas_Respondidas(registry **);

//====|CONSIGNAS|TODOS|====
//====|PONDERACION X|====
void ponderacion(registry *r, Encuesta *p, Pregunta *l, Respuesta *c, long long id, float *sumaTotal, int *cantidad,int *b);

//====|MOSTRAR ENCUESTAS RESP EN EL ARBOL|====
void mostrar_arbol(registry *);

//====|MOSTRAR ENCUESTAS RESP. COMPLETAS|====
void mostrar_completa(registry *a, Encuesta *p, Pregunta *l, Respuesta *c);

//====|MOSTRAR RESPONDIDAS DE UNA ENCUESTA|====
void listarRespondidasPorEncuestaId(registry *raiz, long long idEncuestaOriginal);

//----------------|MAIN|----------------------------
int main() {
	int eleccion=-1,cantidadEncuestas = 0,b;
	float totalPonderacion = 0;
	long long id;
	char auxiliar[50];
	Pregunta *pregL = NULL;
	Respuesta *respL = NULL;
	registry *raiz = NULL;
	Encuesta *head = NULL;
	
	leerCSVencuestas(&head); 
	leerRespuestasCSV("respuestas.csv",&respL);
 	cargarPreguntasDesdeCSV(&pregL);
	Leer_CSV_Encuestas_Respondidas(&raiz);
	
	while (eleccion != 0) {
		puts("\n================= MENU PRINCIPAL =================\n1. CRUD de Encuestas\n2. CRUD de Preguntas\n3. CRUD de Respuestas\n4. Consignas\n0. Salir\n==================================================\nSeleccione una opcion: ");
	    fflush(stdin);
	    fgets(auxiliar, sizeof(auxiliar), stdin);
	    eleccion = atoi(auxiliar);
	
	    switch (eleccion) {
	        case 1:
	            menuEncuestas(&head, &pregL, &respL);
	            break;
	        case 2:
	            Crud_Preguntas(&head, &pregL, &respL);
	            break;
	        case 3:
	            crudRespuestas(pregL, &respL);
	            break;
	        case 4: {
	            int subopcion;
	            puts("\n================== CONSIGNAS =====================\n1. Calcular ponderacion de una encuesta modelo\n2. Mostrar todas las encuestas respondidas (ABB)\n3. Mostrar encuestas respondidas una a una\n4. Ver encuestas respondidas de un modelo especifico\n==================================================\nSeleccione una opcion: ");	            
	            fflush(stdin);
	            scanf("%d", &eleccion);
	
	            switch (eleccion) {
	                case 1:
	                	b=0;
	                    printf("Ingrese el ID de la encuesta original: ");
	                    fflush(stdin);
	                    scanf("%lld", &id);
	                    ponderacion(raiz, head, pregL, respL, id, &totalPonderacion, &cantidadEncuestas,&b);
						
						if(b){
							if (cantidadEncuestas > 0) {
							    printf("\n================= RESUMEN TOTAL ENCUESTA ID = %d =================\n", 15);
							    printf("| %-20s | %-40s \n", "Total Sum Pond", "Cant Pond");
							    printf("| %-20.3f | %-40d \n", totalPonderacion, cantidadEncuestas);
							    printf("| %-44s\n", " ");
							    printf("| %-20s = %-20.3f \n", "PROMEDIO FINAL", totalPonderacion / cantidadEncuestas);
							    printf("==================================================================\n");
							} else
							    printf("No se encontraron respuestas para la encuesta con ID %d\n", 15);
						}else
							puts("no se encontraron encuestas repondidadas con el ID encuesta original.");
					break;
	
	                case 2:
	                    mostrar_arbol(raiz);
	                break;
	
	                case 3:
	                    printf("Encuestas respondidas completas:\n");
	                    mostrar_completa(raiz, head, pregL, respL);
	                    break;
	
	                case 4:
	                    printf("Ingrese el ID del modelo de encuesta: ");
	                    fflush(stdin);
	                    scanf("%lld", &id);
	                    printf("Listado de encuestas respondidas para el modelo %lld:\n", id);
	                    listarRespondidasPorEncuestaId(raiz, id);
	                    break;
	
	                default:
	                    printf("Opción inválida en consignas.\n");
	            }
	            break;
	        }
	        case 0:
	            printf("Saliendo del programa...\n");
	            break;
	
	        default:
	            printf("Opción inválida. Intente de nuevo.\n");
	    }
	}

	
	return 0;
}

//===================================|FUNCIONES|===================================
void ponderacion(registry *r, Encuesta *p, Pregunta *l, Respuesta *c, long long id, float *sumaTotal, int *cantidad,int *b){
    if (r == NULL)
        return;

    // Recorrer subarbol izquierdo
    ponderacion(r->izq, p, l, c, id, sumaTotal, cantidad,b);

    if (r->Encuesta_Id == id) {
    	*b=1;
        float pond = 0;
        int band;
        Pregunta *auxl = NULL;
        Respuesta *auxc = NULL;
        Marcado *auxa = r->listaPreguntas;

        printf("\n==================================================\n");
        printf(" Encuesta Respondida ID: %lld\n", r->idEncuestaRespondida);
        printf("==================================================\n");

        while (auxa != NULL) {
            auxl = l;
            band = 0;

            // Buscar pregunta correspondiente
            while (auxl != NULL && band == 0) {
                if (auxl->Pregunta_Id == auxa->Pregunta_Id) {
                    printf("\n[Pregunta ID: %lld] | Ponderacion: %.2f\n", auxl->Pregunta_Id, auxl->Ponderacion);
                    band = 1;
                } else {
                    auxl = auxl->sgte;
                }
            }

            // Buscar respuesta y calcular ponderacion
            if (band == 1 && c != NULL) {
                band = 0;
                auxc = c;

                do {
                    if (auxc->Respuesta_Id == auxa->Respuesta_Id) {
                        pond += auxc->Ponderacion * auxl->Ponderacion;
                        printf("Respuesta ID: %lld | Ponderacion: %.2f | Valor: %.2f | Acumulado: %.2f\n",auxc->Respuesta_Id, auxc->Ponderacion, auxc->Ponderacion * auxl->Ponderacion, pond);
                        band = 1;
                    } else {
                        auxc = auxc->sgte;
                    }
                } while (auxc != c && band == 0);
            }

            auxa = auxa->sgte;
        }

        printf("--------------------------------------------------\n");
        printf("Total ponderado para Encuesta Respondida ID %lld: [ %.3f ]\n", r->idEncuestaRespondida, pond);
        printf("==================================================\n");

        *sumaTotal += pond;
        (*cantidad)++;
    }

    // Recorrer subarbol derecho
    ponderacion(r->der, p, l, c, id, sumaTotal, cantidad,b);
}

void mostrar_completa(registry *a, Encuesta *p, Pregunta *l, Respuesta *c){

	if (a == NULL)
		return;
	
	if (c == NULL) {
	    printf("Error: lista de respuestas vacía.\n");
	    return;
	}
	
	mostrar_completa(a->izq, p, l, c);
		

	int marcada;
	Pregunta *auxl=NULL;
	Respuesta *auxc=NULL;
	Marcado *auxa=NULL;	
	Encuesta *auxp = p;	
	int existeEncuesta = 0;
	
	while (auxp != NULL && !existeEncuesta){
	    if (auxp->Encuesta_Id == a->Encuesta_Id){
			existeEncuesta = 1;
		}else
	        auxp = auxp->sgte;
	}
	
	if (existeEncuesta) {
	
		puts("==============================================================================================");
	    printf("--- Encuesta Respondida ID: %lld ---\nEncuesta original ID: %lld | Fecha: %s\n", a->idEncuestaRespondida,a->Encuesta_Id, a->fecha);
	    
		auxl=l;
		while(auxl!=NULL){// Recorrer la lista de preguntas
			   
			if(auxl->Encuesta_Id==a->Encuesta_Id){//preguntas que le pertenece a la encuesta respondida
				printf("Pregunta: %s\n",auxl->Pregunta);
				auxc = c;
				do{//busco todas las respuestas de cada pregunta
					
					if(auxl->Pregunta_Id == auxc->Pregunta_Id){//respuestas que le pertenecen a cada pregunta
			
					    auxa = a->listaPreguntas;
	                    marcada = 0;
	                    while (auxa != NULL && !marcada) {
	                        if (auxa->Respuesta_Id == auxc->Respuesta_Id)
	                            marcada = 1;                            
	                        
	                        auxa = auxa->sgte;
	                    }
	
	                    if (marcada)
	                        printf("\t[X] %s\n", auxc->Respuesta);
	                    else
	                        printf("\t -  %s\n", auxc->Respuesta);
					}
					
					auxc = auxc->sgte;				
				}while (auxc != c);	
			}
			
			auxl=auxl->sgte;
		}							
	
	}else
		printf("\nError: No se encontro la encuesta original con ID %lld para la respondida con ID %lld.\n",a->Encuesta_Id, a->idEncuestaRespondida);
	
	mostrar_completa(a->der, p, l, c);
}

void listarRespondidasPorEncuestaId(registry *raiz, long long idEncuestaOriginal){
    if (raiz == NULL)
        return;

    // Recorre subárbol izquierdo
    listarRespondidasPorEncuestaId(raiz->izq, idEncuestaOriginal);

    // Si pertenece a la encuesta original, la muestra
    if (raiz->Encuesta_Id == idEncuestaOriginal) {
        printf("Encuesta Respondida ID: %lld (pertenece a modelo ID: %lld)\n",
               raiz->idEncuestaRespondida, raiz->Encuesta_Id);
    }

    // Recorre subárbol derecho
    listarRespondidasPorEncuestaId(raiz->der, idEncuestaOriginal);
}

//===================================|ARBOL|===================================
void Agregar_Registro_Encuesta_Respondida(){
	
	if ((encuestas_respondidas_CSV = fopen("Encuestas_RESPONDIDAS.txt", "a+"))!= NULL) {
	    puts("\n---Agregar Registro---\n");
	    
	    printf("Ingrese ID Encuesta (6 digitos): ");
	    fflush(stdin);
		scanf("%lld", &reg2.Encuesta_Id);
	
		reg2.listaPreguntas = (Marcado*) malloc(sizeof(Marcado));
		
	    printf("Ingrese ID Pregunta (8 digitos): ");
	    fflush(stdin);
		scanf("%lld", &reg2.listaPreguntas->Pregunta_Id);
	
	    printf("Ingrese ID Respuesta (12 digitos): ");
	    fflush(stdin);
		scanf("%lld", &reg2.listaPreguntas->Respuesta_Id);		
	    
		printf("Ingrese Fecha (YYYYMMDD): ");
		fflush(stdin);
		scanf("%8s", reg2.fecha);

	    printf("Ingrese ID Encuestador (4 digitos): ");
	    fflush(stdin);
		scanf("%lld", &reg2.encuestador);
	
	    printf("Ingrese ID Encuesta Respondida (12 digitos): ");
	    fflush(stdin);
		scanf("%lld", &reg2.idEncuestaRespondida);
	
		fprintf(encuestas_respondidas_CSV, "%06lld%08lld%012lld%s%04lld%012lld\n", reg2.Encuesta_Id,reg2.listaPreguntas->Pregunta_Id, reg2.listaPreguntas->Respuesta_Id, reg2.fecha, reg2.encuestador, reg2.idEncuestaRespondida);
	
	    fclose(encuestas_respondidas_CSV);
	    puts("Registro agregado correctamente.");
		free(reg2.listaPreguntas);
	}else
		puts("Error.");
}

void Leer_CSV_Encuestas_Respondidas(registry **r){
    char linea[200];
    
    if ((encuestas_respondidas_CSV = fopen("Encuestas_RESPONDIDAS.txt", "r"))!= NULL) {
	    
	    while (fgets(linea, sizeof(linea), encuestas_respondidas_CSV)) {
			
			registry *nv = (registry*) malloc(sizeof(registry));
			nv->der=NULL;
			nv->izq=NULL;
			
			nv->listaPreguntas = (Marcado*) malloc(sizeof(Marcado));
	        nv->listaPreguntas->sgte=NULL;
	        
			sscanf(linea,"%6lld%8lld%12lld%8s%4lld%12lld", &nv->Encuesta_Id,&nv->listaPreguntas->Pregunta_Id, &nv->listaPreguntas->Respuesta_Id, nv->fecha, &nv->encuestador, &nv->idEncuestaRespondida);
			
			//printf("Encuesta: %06lld | Pregunta: %08lld | Respuesta: %012lld | Fecha: %s | Encuestador: %04lld | ID Resp: %012lld\n", nv->Encuesta_Id,nv->listaPreguntas->Pregunta_Id, nv->listaPreguntas->Respuesta_Id, nv->fecha, nv->encuestador, nv->idEncuestaRespondida);

			*r = insertar_arbol(*r,nv);
	    }
	    fclose(encuestas_respondidas_CSV);
	    
    }else
		puts("Error.");
}

registry* insertar_arbol(registry *r, registry *n) {
    if (r != NULL) {
        if (r->idEncuestaRespondida == n->idEncuestaRespondida) {
            if (r->listaPreguntas == NULL) {
				// Primer nodo en la lista
				r->listaPreguntas= n->listaPreguntas;
			} else {
				//insertar al final
				Marcado* actual = r->listaPreguntas;
				while (actual->sgte != NULL) {
				    actual = actual->sgte;
				}
					actual->sgte = n->listaPreguntas;
			}
			free(n);
        } else
			if (n->idEncuestaRespondida < r->idEncuestaRespondida) {
            r->izq = insertar_arbol(r->izq, n);
        } else {
            r->der = insertar_arbol(r->der, n);
        }
    } else {
        r = n;
        r->izq = r->der = NULL;
    }
    return r;
}

void mostrar_arbol(registry *r) {
	if (r == NULL)
		return;

    // Mostrar subárbol izquierdo
    mostrar_arbol(r->izq);

    // Mostrar datos del nodo actual
    printf("\nEncuesta Respondida ID: %012lld | Encuesta ID: %06lld | Fecha: %s | Encuestador: %04lld\nPreguntas y Respuestas:\n", r->idEncuestaRespondida, r->Encuesta_Id, r->fecha, r->encuestador);

    // Recorrer la lista de preguntas
    Marcado* actual = r->listaPreguntas;
    while (actual != NULL) {
        printf("Pregunta ID: %08lld | Respuesta ID: %012lld\n", 
               actual->Pregunta_Id, actual->Respuesta_Id);
        actual = actual->sgte;
    }

    // Mostrar subárbol derecho
    mostrar_arbol(r->der);
}

//===================================|PREGUNTAS|===================================
void Crud_Preguntas(Encuesta **tp, Pregunta **l, Respuesta **respL) { 
    int eleccion = -1;
    long long id;

    Pregunta *aux = *l;

    puts(
        "\n=========== MENU DE PREGUNTAS ===========\n"
        "1. Crear pregunta\n"
        "2. Leer preguntas\n"
        "3. Modificar pregunta\n"
        "4. Borrar pregunta\n"
        "0. Volver al menu anterior\n"
        "=========================================\n"
        "Seleccione una opcion: "
    );
    fflush(stdin);
    scanf("%d", &eleccion);

    while (eleccion != 0) {
        switch (eleccion) {
            case 1:
                ListaDeEncuestas(tp); 
                puts(">>> Se han listado las encuestas para crear preguntas correctamente.");
                puts(">>> Modulo: Crear pregunta");
                crearPregunta(l,*tp); //
                break;

            case 2:
                puts(">>> Modulo: Leer preguntas");
                mostrarPregunta(*l);
                break;

            case 3:
            	mostrarPregunta(*l);
            	puts(">>> Se han listado las preguntas para modificarlas correctamente."); //
                puts(">>> Modulo: Modificar pregunta");
                printf("Ingrese el ID de la pregunta a modificar: ");
                scanf("%lld", &id);
                modificarPregunta(l, id, *tp); //
                break;

            case 4:
                ListaDeEncuestas(tp);
                puts(">>> Se han listado las encuestas para borrar preguntas correctamente.");
                puts(">>> Modulo: Borrar pregunta");
                printf("Ingrese el ID de la encuesta de las preguntas a borrar: ");
                scanf("%lld", &id);
                borrarPregunta(l, id, respL, *tp);
                break;

            case 0:
                puts(">>> Saliendo del modulo de preguntas...");
                break;

            default:
                puts(">>> Opcion invalida. Intente de nuevo.");
        }

        puts(
            "\n=========== MENU DE PREGUNTAS ===========\n"
            "1. Crear pregunta\n"
            "2. Leer preguntas\n"
            "3. Modificar pregunta\n"
            "4. Borrar pregunta\n"
            "0. Volver al menu anterior\n"
            "=========================================\n"
            "Seleccione una opcion: "
        );
        fflush(stdin);
        scanf("%d", &eleccion);
    }
}


void cargarPreguntasDesdeCSV(Pregunta **head) {
    FILE *archivo = fopen("preguntas.csv", "r");
    if (archivo == NULL) {
        printf("Error al abrir preguntas.csv\n");
        return;
    }

    char linea[256];
    int contador = 0;

    while (fgets(linea, sizeof(linea), archivo) != NULL) {
        contador++;
        linea[strcspn(linea, "\r\n")] = '\0';  // Eliminar retorno de carro y salto de línea

        Pregunta *nueva = malloc(sizeof(Pregunta));
        if (nueva == NULL) {
            printf("Error de memoria\n");
            fclose(archivo);
            return;
        }

        // Extraer IDs
        char idPreguntaStr[9] = {0};
        char idEncuestaStr[7] = {0};
        strncpy(idPreguntaStr, linea, 8);
        strncpy(idEncuestaStr, linea + 8, 6);
        nueva->Pregunta_Id = atoll(idPreguntaStr);
        nueva->Encuesta_Id = atoll(idEncuestaStr);

	      for (int i = strlen(linea) - 1; i >= 0; i--) {
		    if ((linea[i] >= '0' && linea[i] <= '9') || linea[i] == ',' || linea[i] == '.') {
		        int j = i;
		        while (j >= 0 && ((linea[j] >= '0' && linea[j] <= '9') || linea[j] == ',' || linea[j] == '.')) {
		            j--;
		        }
		
		        char ponderacionStr[16] = {0};
		        strncpy(ponderacionStr, linea + j + 1, i - j);
		
		        // Reemplazar coma por punto
		        for (int k = 0; ponderacionStr[k] != '\0'; k++) {
		            if (ponderacionStr[k] == ',') {
		                ponderacionStr[k] = '.';
		            }
		        }
		
		        nueva->Ponderacion = atof(ponderacionStr);

		        break;
		    }
		}

        // Extraer texto
        int len = strlen(linea); 
        int textoLen = len - 8 - 6 - 4;
        if (textoLen > 0) {
            strncpy(nueva->Pregunta, linea + 14, textoLen);
            nueva->Pregunta[textoLen] = '\0';
        } else {
            strcpy(nueva->Pregunta, "");
            printf("No se pudo extraer texto\n");
        }

        // Insertar en lista
        nueva->sgte = NULL;
        if (*head == NULL) {
            *head = nueva;
        } else {
            Pregunta *actual = *head;
            while (actual->sgte != NULL) {
                actual = actual->sgte;
            }
            actual->sgte = nueva;
        }

    }

    fclose(archivo);	
}

void crearPregunta(Pregunta **l, Encuesta *e) { //
    Pregunta *p = NULL, *aux = NULL;
    Encuesta *auxe = e;
    long long nuevoid = 1, eid;
    int existeEncuesta = 0;
    
    // Pedir ID de Encuesta
    printf("Ingrese ID de la encuesta asociada: ");
    fflush(stdin);
    scanf("%lld", &eid);
    
    // Buscar si la encuesta existe
    while (auxe != NULL && !existeEncuesta) {
        if (auxe->Encuesta_Id == eid) {
            existeEncuesta = 1;
        } else {
            auxe = auxe->sgte;
        }
    }
    
    if (!existeEncuesta) {
        puts("Encuesta NO encontrada.");
        return;
    }

    // Calcular suma de ponderaciones actuales
    float sumaPonderacion = 0.0;
    Pregunta *temp = *l;
    while (temp != NULL) {
        if (temp->Encuesta_Id == eid)
            sumaPonderacion += temp->Ponderacion;
        temp = temp->sgte;
    }

    // Cargar preguntas hasta completar ponderación 1.0
    while (sumaPonderacion < 1.0) {
        p = (Pregunta *)malloc(sizeof(Pregunta));
        if (p == NULL) {
            printf("No hay espacio de memoria.\n");
            return;
        }

        p->Encuesta_Id = eid;

        // Obtener nuevo ID
        nuevoid = 1;
        aux = *l;
        while (aux != NULL) {
            if (aux->Pregunta_Id >= nuevoid)
                nuevoid = aux->Pregunta_Id + 1;
            aux = aux->sgte;
        }
        p->Pregunta_Id = nuevoid;

        fflush(stdin);
        printf("Ingrese el texto de la pregunta: ");
        fgets(p->Pregunta, 50, stdin);
        p->Pregunta[strcspn(p->Pregunta, "\n")] = '\0';

        float maxPermitido = 1.0 - sumaPonderacion;
        printf("Ingrese la ponderacion (0.01 a %.2f): ", maxPermitido);
        scanf("%f", &p->Ponderacion);

        if (p->Ponderacion < 0.01 || p->Ponderacion > maxPermitido) {
            printf("Error: La ponderacion debe ser entre 0.01 y %.2f\n", maxPermitido);
            free(p);
            continue; // Volver a intentar
        }

        sumaPonderacion += p->Ponderacion;
        *l = insertarPregunta(p, *l);
        printf("Pregunta creada con ID: %lld (Ponderacion acumulada: %.2f/1.0).\nDebe continuar creando preguntas hasta completar 1.0.\n", p->Pregunta_Id, sumaPonderacion);

        if (sumaPonderacion >= 1.0) {
            puts("Ponderacion total completada para esta encuesta");
            break;
        }
    }
}


Pregunta* insertarPregunta(Pregunta *p, Pregunta *r) {
    if (r == NULL || p->Pregunta_Id < r->Pregunta_Id) {
        p->sgte = r;
        return p;
    } else {
        r->sgte = insertarPregunta(p, r->sgte);
        return r;
    }
}

void mostrarPregunta(Pregunta *l) { // ?
    if (l == NULL) {
        puts("No hay preguntas cargadas.");
        return;
    }

    printf("\n| PREGUNTAS EXISTENTES |\n");
    printf("====================================================================================================\n");
    printf("| %-12s | %-12s | %-50s | %-10s |\n", 
           "PREGUNTA ID", "ENCUESTA ID", "PREGUNTA", "PONDERACION");
    printf("====================================================================================================\n");

    while (l != NULL) {
        char preguntaCortada[51];
        strncpy(preguntaCortada, l->Pregunta, 50);
        preguntaCortada[50] = '\0'; // Asegurarse del terminador

        printf("| %-12lld | %-12lld | %-50s | %-10.2f  |\n", 
               l->Pregunta_Id, 
               l->Encuesta_Id, 
               preguntaCortada, 
               l->Ponderacion);

        l = l->sgte;
    }

    printf("====================================================================================================\n");
    printf("--- FIN DE LOS ID PREGUNTAS EXISTENTES ---\n");
}

void modificarPregunta(Pregunta **l, long long id, Encuesta *e) { //
    Pregunta *actual = *l;

    // Buscar pregunta por ID
    while (actual != NULL && actual->Pregunta_Id != id)
        actual = actual->sgte;

    if (actual == NULL) {
        puts("Pregunta no encontrada.");
        return;
    }

    fflush(stdin);
    printf("Ingrese nuevo texto para la pregunta: ");
    fgets(actual->Pregunta, 50, stdin);
    actual->Pregunta[strcspn(actual->Pregunta, "\n")] = '\0';

    // Calcular suma de ponderaciones de otras preguntas de la misma encuesta
    float sumaOtras = 0.0;
    Pregunta *aux = *l;
    while (aux != NULL) {
        if (aux != actual && aux->Encuesta_Id == actual->Encuesta_Id)
            sumaOtras += aux->Ponderacion;
        aux = aux->sgte;
    }

    float maxPermitido = 1.0 - sumaOtras;
    printf("Ingrese nueva ponderacion (0.01 a %.2f): ", maxPermitido);
    float nuevaPond;
    scanf("%f", &nuevaPond);

    if (nuevaPond < 0.01 || nuevaPond > maxPermitido) {
        puts("Ponderación inválida.");
        return;
    }

    actual->Ponderacion = nuevaPond;
    puts("Pregunta modificada correctamente.");

    float sumaTotal = sumaOtras + nuevaPond;
    if (sumaTotal < 1.0) {
        printf("\nLa suma total de ponderaciones es %.2f (debe ser 1.0).\n", sumaTotal);

        int opcion;
        do {
            puts("\nElija una accion para compensar:");
            puts("1. Modificar otra pregunta existente");
            puts("2. Insertar nueva pregunta");
            puts("3. Cancelar (dejar inconsistente)");

            printf("Opcion: ");
            scanf("%d", &opcion);

            if (opcion == 1) {
                long long otroId;
                printf("Ingrese ID de la otra pregunta a modificar: (Que sea de la misma encuesta) "); // 
                scanf("%lld", &otroId);

                if (otroId == id) {
                    puts("No puedes elegir la misma pregunta.");
                } else {
                    modificarPregunta(l, otroId, e);  // llamada recursiva segura
                }

            } else if (opcion == 2) { // 
                crearPregunta(l, e);  // usar función ya hecha
            } else if (opcion == 3) {
                puts("Advertencia: Ponderación total incompleta.");
            } else {
                puts("Opción inválida.");
            }

        } while (opcion != 1 && opcion != 2 && opcion != 3);
    }
}

void borrarPregunta(Pregunta **l, long long encuestaId, Respuesta **res, Encuesta *e) {
    Pregunta *act = *l, *ant = NULL, *bor;
    int borradas = 0;

    while (act != NULL) {
        if (act->Encuesta_Id == encuestaId) {
            // Borrar todas las respuestas asociadas a esta pregunta
            borrarRespuestasPorPreguntaId(res, act->Pregunta_Id);

            // Borrar la pregunta actual
            bor = act;
            if (ant == NULL) {
                *l = act->sgte;
                act = *l;
            } else {
                ant->sgte = act->sgte;
                act = ant->sgte;
            }

            free(bor);
            borradas++;
        } else {
            ant = act;
            act = act->sgte;
        }
    }

    if (borradas > 0) {
        puts("Todas las preguntas de la encuesta fueron borradas.");
    } else {
        puts("No se encontraron preguntas asociadas a esa encuesta.");
    }
}

void borrarRespuestasPorPreguntaId(Respuesta **l, long long preguntaId) {
    if (*l == NULL) return; // Lista vacía

    Respuesta *actual = *l;
    Respuesta *anterior = NULL;
    int primeraVuelta = 1;

    do {
        Respuesta *siguiente = actual->sgte;

        if (actual->Pregunta_Id == preguntaId) {
            if (actual == actual->sgte) { // Un único nodo en la lista
                free(actual);
                *l = NULL;
                return;
            } else {
                if (actual == *l) { // Primer nodo
                    Respuesta *ultimo = *l;
                    while (ultimo->sgte != *l) {
                        ultimo = ultimo->sgte;
                    }
                    ultimo->sgte = actual->sgte;
                    *l = actual->sgte;
                    free(actual);
                    actual = *l;
                    // NO actualizar anterior aquí
                    continue; // para reevaluar el nuevo *l
                } else {
                    anterior->sgte = actual->sgte;
                    free(actual);
                    actual = anterior->sgte;
                    continue; // para reevaluar el nuevo actual->Pregunta_Id
                }
            }
        } else {
            anterior = actual;
            actual = siguiente;
        }

        primeraVuelta = 0;
    } while (actual != *l || primeraVuelta);
}


//===================================|RESPUESTAS|===================================
void crudRespuestas(Pregunta *pl, Respuesta **l) {
    int opc;
    long long id;
	
	puts("\n============= MENU CRUD RESPUESTAS =============\n1. Agregar una respuesta\n2. Modificar una respuesta\n3. Borrar una respuesta\n4. Mostrar respuestas\n0. Salir\n===============================================\nSeleccione una opcion: ");
    fflush(stdin);
    scanf("%d", &opc);

    while (opc < 0 || opc > 4) {
        puts("\n¡Opcion invalida! Intente nuevamente.\n============= MENU CRUD RESPUESTAS =============\n1. Agregar una respuesta\n2. Modificar una respuesta\n3. Borrar una respuesta\n4. Mostrar respuestas\n0. Salir\n===============================================\nSeleccione una opcion: ");
        fflush(stdin);
        scanf("%d", &opc);
    }

    switch (opc) {
        case 0:
            printf("Saliendo del CRUD de Respuestas...\n");
            break;

        case 1:
            crearRespuesta(l, pl, 0, 0);
            break;

        case 2:
            puts("\n======= RESPUESTAS EXISTENTES =======");
            mostrarRespuestas(*l);
            printf("Ingrese el ID de la respuesta a modificar: ");
            fflush(stdin);
            scanf("%lld", &id);
            modificarRespuesta(*l, id);
            break;

        case 3:
            puts("\n======= RESPUESTAS EXISTENTES =======");
            mostrarRespuestas(*l);
            printf("Ingrese el ID de la respuesta a borrar: ");
            fflush(stdin);
            scanf("%lld", &id);
            preBorrar(l, id, *l, pl);
            break;

        case 4:
            puts("\n======= RESPUESTAS EXISTENTES =======");
            mostrarRespuestas(*l);
            break;
    }
}
void crearRespuesta(Respuesta **l, Pregunta *pl, int uno, long long idPreg){ //el parametro "uno" sirve para determinar si la ponderacion de la respuesta es "1" u otro valor, 1=1|0=x
	Respuesta *aux = NULL; //sirve solo para recorrer la lista y buscar el maximo id
	int n = 0; //es el numero de respuesta maximo en una misma pregunta
	int primero = 1; //es un booleano que indentifica que esta va a ser la primer respuesta en agragar a una pregunta. Se asume que este es el primero
	int preg = 0; //es otro booleano que identifica si existe la el "id pregunta" o no. 0=no|1=si
	
	Respuesta *p = (Respuesta *) malloc(sizeof(Respuesta));
	if(p == NULL){
		printf("no hay espacio en momoria\n");
		return;
	}
	
	//obtener el mayor id y ponerle +1
	if(*l == NULL){
		p->Respuesta_Id = 1;	
	}else{
		aux = (*l)->sgte;
		while(aux->sgte != *l){
			aux = aux->sgte;
		}
		p->Respuesta_Id = aux->Respuesta_Id + 1;
	}
	
	//cargar id pregunta
	//si idPreg es 0, entonces el idPregunta puede ser cualquier numero
	if(idPreg == 0){
		mostrarPregunta(pl);
		fflush(stdin);
		printf("pregunta id:\n");
		scanf("%lld",&p->Pregunta_Id);
		while(pl != NULL){
			if(pl->Pregunta_Id == p->Pregunta_Id){
				preg = 1;
			}
			pl = pl->sgte;
		}
	}else{//si idPreg es distinto de 0, entonces el idPregunta va a ser idPreg
		p->Pregunta_Id = idPreg;
		preg = 1;
	}
	if(preg == 0){
		printf("no existe el id pregunta, no se puede continuar\n");
		free(p);
		return;
	}
	//obtener el mayor numero de respuesta y ponerle +1
	if(*l == NULL){
		p->Respuesta_Nro = 1;	
	}else{
		aux = (*l);
		while(aux->sgte != *l){
			if(aux->Pregunta_Id == p->Pregunta_Id && aux->Respuesta_Nro > n){ // busca el nodo en la misma pregunta pero con un numero de respuesta mayor
				n = aux->Respuesta_Nro;
			}
			aux = aux->sgte;
		}
		p->Respuesta_Nro = n + 1;
	}
	
	//cargar la ponderacion
	if(uno == 1){
		printf("Se determino anteriormente que la ponderacion de esta respuesta va a ser 1\n");
		p->Ponderacion = 1;
	}else{
		if(*l == NULL){
			printf("la lista esta vacia, la ponderacion va a ser 1. Ingrese la pregunta que corresponda con esta\n");	
			p->Ponderacion = 1;
		}else{
			aux = (*l);
			if(aux->Pregunta_Id == p->Pregunta_Id){
				primero = 0;
			}
			aux = aux->sgte;
			while(aux != *l){
				if(aux->Pregunta_Id == p->Pregunta_Id){
					primero = 0;
				}
				aux = aux->sgte;
			}
			if(primero == 1){
				printf("No existe ninguna respuesta vinculada al 'id pregunta' anterior. La poneracion sera '1' por lo que el texto de la respuesta debera corresponder a esta ponderacion\n");
				p->Ponderacion = 1;
			}else{
				fflush(stdin);
				printf("Ingrese la ponderacion ENTRE 0 y 1 (no mas, menos o 1)\n");
				scanf("%f",&p->Ponderacion);
				while(p->Ponderacion < 0 || p->Ponderacion >= 1){
					if(p->Ponderacion == 1){
						printf("Ya existe un ponderacion 1, pureba otra ponderacion\n");
					}
					printf("Ingrese la ponderacion ENTRE 0 y 1 (no mas, menos o 1)\n");
					scanf("%f",&p->Ponderacion);
				}
			}
		}
	}
	
	//cargar el texto de la respuesta, MODIFICAR CUANDO EXISTAN LOS DEMAS CRUDS por si hay limitantes
	fflush(stdin);
	printf("ingrese la respuesta (texto):\n");
	gets(p->Respuesta);
	
	p->sgte = NULL;
	insertarRespuesta(&(*l),p,(*l));
	printf("Se creo una nueva respuesta!\n");
}

void insertarRespuesta(Respuesta **l, Respuesta *nv, Respuesta *r){
	Respuesta *aux;
	if(*l != NULL){
		if(nv->Respuesta_Id < (*l)->Respuesta_Id){
			nv->sgte = *l;
			if(nv->Respuesta_Id < r->Respuesta_Id){
				aux = *l;
				while(aux->sgte != *l){
					aux = aux->sgte;
				}
				aux->sgte = nv;
			}
			*l = nv;
		}
		else{
			if((*l)->sgte == r){
				(*l)->sgte = nv;
				nv->sgte = r;
			}
			else{
				insertarRespuesta(&(*l)->sgte,nv,r);
			}
		}
	}
	else{
		*l = nv;
		(*l)->sgte = *l;
	}
}

void mostrarRespuestas(Respuesta *l) {
    Respuesta *r = l;

    if (l != NULL) {
        // Encabezado
        printf("--------------------------------------------------------------------------------------------------------------\n");
        printf("| %-12s | %-12s | %-14s | %-30s | %-12s |\n", 
               "RESPUESTA ID", "PREGUNTA ID", "RESPUESTA NRO", "RESPUESTA", "PONDERACION");
        printf("--------------------------------------------------------------------------------------------------------------\n");

        do {
            printf("| %-12lld | %-12lld | %-14d | %-30s | %-12.2f |\n", 
                   l->Respuesta_Id, l->Pregunta_Id, l->Respuesta_Nro, l->Respuesta, l->Ponderacion);
            l = l->sgte;
        } while (l != r);

        printf("--------------------------------------------------------------------------------------------------------------\n");
    } else {
        printf("La lista esta vacia\n");
    }
}


void modificarRespuesta(Respuesta *l, long long id){
	Respuesta *r; // "r" representa en todos los casos donde comienza y termina la lista para no tener entrar en bucle infinito
	int encontrado = 0; //Es una bandera que indica si se encontro al nodo o no
	if(l != NULL){
		r = l;
		//comparar en el primer nodo
		if(l->Respuesta_Id == id){
			encontrado = 1;
			printf("Respuesta (antes: '%s'):\n",l->Respuesta);
			fflush(stdin);
			gets(l->Respuesta);
			fflush(stdin);
			if(l->Ponderacion == 1){
				printf("La ponderacion es 1, este dato no puede ser modificado. De querer hacerlo debera borrarlo y crear otro nodo o modificar el texto de la respuesta\nComo la ponderacion es 1, no se permite que esta respuesta sea trasladada a otra pregunta.\n");
			}else{
				printf("Ponderacion del 0 al 1 (antes: '%.2f'):\n",l->Ponderacion);
				fflush(stdin);
				scanf("%f",&l->Ponderacion);
				printf("Pregunta id (antes: '%d'):\n",l->Pregunta_Id);
				fflush(stdin);
				scanf("%lld",&l->Pregunta_Id);
			}
			printf("|Datos modificados!|\n");
			return;
		}
		
		//comparar con el resto
		l = l->sgte;
		while(l != r){
			//se encontro y se modifican los datos del nodo menos el de "Respuesta ID"
			if(l->Respuesta_Id == id){
				encontrado = 1;
				printf("Respuesta (antes: '%s'):\n",l->Respuesta);
				fflush(stdin);
				gets(l->Respuesta);
				fflush(stdin);
				if(l->Ponderacion == 1){
					printf("La ponderacion es 1, este dato no puede ser modificado. De querer hacerlo debera borrarlo y crear otro nodo o modificar el texto de la respuesta\nComo la ponderacion es 1, no se permite que esta respuesta sea trasladada a otra pregunta.\n");
				}else{
					printf("Ponderacion del 0 al 1 (antes: '%.2f'):\n",l->Ponderacion);
					fflush(stdin);
					scanf("%f",&l->Ponderacion);
					printf("Pregunta id (antes: '%d'):\n",l->Pregunta_Id);
					fflush(stdin);
					scanf("%lld",&l->Pregunta_Id);
				}
				printf("|Datos modificados!|\n");
			}
			l = l->sgte;
		}
		if(encontrado == 0){
			printf("No se encontro al nodo\n");
		}
	}else{
		printf("La lista esta vacia\n");
	}
}
void preBorrar(Respuesta **l, long long id, Respuesta *r, Pregunta *pl){
	Respuesta *aux = NULL;
	Respuesta *temp = *l;
	int cont = 0, opc;
	if(*l != NULL){
		aux = *l;
		if(aux->Respuesta_Id == id){
			//borrar y cargar nuevo si es pond 1
			if(aux->Ponderacion == 1){
				do {
    			    if (temp->Pregunta_Id == aux->Pregunta_Id) {
          			  cont++;
       				}
        			temp = temp->sgte;
    			}while (temp != *l);
    			if(cont > 1){
    				printf("Se esta eliminando la unica respuesta con ponderacion 1 para esta pregunta.\n");
      				printf("Se creara automáticamente otra con ponderacion 1.\n");
       				crearRespuesta(&(*l),pl,1,aux->Pregunta_Id);
       				borrarRespuesta(&(*l),id,*l);
				}else{
					printf("Se Esta eliminando la unica respuesta de la pregunta %lld con ponderacion 1.\n", aux->Pregunta_Id);
					printf("¿Desea eliminarla igual? (1 = si| otro = no):\n");
					fflush(stdin);
					scanf("%d",&opc);
					if(opc == 1){
						borrarRespuesta(&(*l),id,*l);
						printf("Respuesta eliminada.\n");
					}else{
						printf("Se cancelo la eliminacion.\n");
					}
				}
			}else{
				borrarRespuesta(&(*l),id,*l);
			}
		}else{
			aux = aux->sgte;
			while(aux != *l){
				if(aux->Respuesta_Id == id){
					//borrar y cargar nuevo si es pond 1
					if(aux->Ponderacion == 1){
						do {
    					    if (temp->Pregunta_Id == aux->Pregunta_Id) {
         		 			  cont++;
       						}
        					temp = temp->sgte;
    					}while (temp != *l);
    					if(cont > 1){
    						printf("Se esta eliminando la unica respuesta con ponderacion 1 para esta pregunta.\n");
      						printf("Se creara automaticamente otra con ponderacion 1.\n");
       						crearRespuesta(&(*l),pl,1,aux->Pregunta_Id);
       						borrarRespuesta(&(*l),id,*l);
						}else{
							printf("Se Esta eliminando la unica respuesta de la pregunta %lld con ponderacion 1.\n", aux->Pregunta_Id);
							printf("¿Desea eliminarla igual? (1 = si| otro = no):\n");
							fflush(stdin);
							scanf("%d",&opc);
							if(opc == 1){
								borrarRespuesta(&(*l),id,*l);
								printf("Respuesta eliminada.\n");
							}else{
								printf("Se cancelo la eliminacion.\n");
							}
						}
					}else{
						borrarRespuesta(&(*l),id,*l);
					}
				}
				aux = aux->sgte;
			}
		}
	}else{
		printf("La lista esta vacia\n");
	}
}

void borrarRespuesta(Respuesta **l, long long id, Respuesta *r){
	Respuesta *bor, *ult;
	if(*l != NULL){
		if((*l)->Respuesta_Id == id){
			if(*l == r){
				ult = *l;
				while(ult->sgte != r){
					ult = ult->sgte;
				}
				ult->sgte = (*l)->sgte;
			}
			bor = *l;
			*l = (*l)->sgte;
			if(*l == bor){
				*l = NULL;
			}
			free(bor);
			printf("|se borro la respuesta|\n");
		}else{
			if((*l)->sgte == r){
				printf("Fin de la lista, no se encontro al nodo\n");
			}else{
				borrarRespuesta(&(*l)->sgte,id,r);
			}
		}
	}
}

void leerRespuestasCSV(const char* nombreArchivo, Respuesta **inicio) {
    FILE* archivo = fopen(nombreArchivo, "r");
    if (!archivo) {
        printf("No se pudo abrir el archivo: %s\n", nombreArchivo);
        return;
    }

    char linea[256];

    while (fgets(linea, sizeof(linea), archivo)) {
        Respuesta *nuevo = (Respuesta*) malloc(sizeof(Respuesta));
        if (!nuevo) {
            printf("Error al reservar memoria\n");
            fclose(archivo);
            return;
        }

        // Extracción de campos numéricos fijos
        char idStr[13] = {0}, preguntaStr[13] = {0}, nroStr[13] = {0};
        strncpy(idStr, linea, 12);
        strncpy(preguntaStr, linea + 12, 12);
        strncpy(nroStr, linea + 24, 12);

        nuevo->Respuesta_Id = atoll(idStr);
        nuevo->Pregunta_Id = atoll(preguntaStr);
        nuevo->Respuesta_Nro = atoll(nroStr);

        // Buscar última coma (que es la de la ponderación)
        char* coma = strrchr(linea, ',');
        if (!coma) {
            printf("Error: no se encontró coma decimal\n");
            free(nuevo);
            continue;
        }

        // Extraer parte flotante
        char ponderacionStr[10];
        strncpy(ponderacionStr, coma - 1, 6); // captura " 0,75" o " 1,00"
        ponderacionStr[6] = '\0';

        // Reemplazar coma por punto para atof
        for (int i = 0; ponderacionStr[i]; i++) {
            if (ponderacionStr[i] == ',') {
                ponderacionStr[i] = '.';
            }
        }

        nuevo->Ponderacion = atof(ponderacionStr);

        
        int inicioTexto = 36; // 12+12+12
        int finTexto = coma - linea; // posición de la coma

        int longitudTexto = finTexto - inicioTexto;
        if (longitudTexto >= 50) longitudTexto = 49;

        strncpy(nuevo->Respuesta, linea + inicioTexto, longitudTexto);
		nuevo->Respuesta[longitudTexto] = '\0';

		
		for (int i = longitudTexto - 1; i >= 0; i--) {
 		   if (nuevo->Respuesta[i] == ' ' || (nuevo->Respuesta[i] >= '0' && nuevo->Respuesta[i] <= '9')) {
  		      nuevo->Respuesta[i] = '\0';
  		  } else {
  		      break;
 		   }
		}
        nuevo->sgte = NULL;

       insertarRespuesta(&(*inicio),nuevo,*inicio);
    }

    fclose(archivo);
}

//===================================|Encuestas|===================================

void apilar(Encuesta * node, Encuesta **head){

    node->sgte = *head;
    *head = node;
}

int pilavacia(Encuesta *head){
    if (head == NULL){
        return 1;
    }
    else 
        return 0;
}
Encuesta * desapilar(Encuesta **head)
{
    Encuesta * tmp = *head;
    if (pilavacia(*head) == 0)
    {
        *head = (*head)->sgte;
        tmp->sgte = NULL;
        return  tmp;
    }
}

void crearEncuesta(Encuesta ** head){	
	char id[20];
	char id2[20];
	char bufferCleaner; 
	FILE * EncuestaCSV = NULL;   
	time_t currentTime = time(NULL);
	struct tm *monthYear = localtime(&currentTime); 
	Encuesta * newNode = (Encuesta*)malloc(sizeof(Encuesta));
	if (newNode == NULL)
	{
	    printf("Error en la memoria");
	    return;
	}
	unsigned __int32 rand;
	rand_s(&rand);
	long long randomNumber = (long long)rand;
	sprintf(id, "%lld", randomNumber);
	strncpy(id2, id, 6);
	randomNumber = strtoll(id2, NULL,0 );
	
	printf("Ingresar nombre de la encuesta\n");
	fgets(newNode->Denominacion, sizeof(newNode->Denominacion), stdin);
	newNode->Denominacion[strcspn(newNode->Denominacion, "\n")] = 0;
	newNode->Encuesta_Anio = monthYear->tm_year + 1900;
	newNode->Encuesta_Mes = monthYear->tm_mon + 1;
	newNode->Procesada = 0;
	newNode->sgte = NULL;
	newNode->Encuesta_Id = randomNumber;
	apilar(newNode, head);
	printf("-----Encuesta nueva creada----- \n Denominacion: %s \n id: %lld \n fecha: %d/%d \n Estado de procesamiento: %d\n", newNode->Denominacion, newNode->Encuesta_Id, newNode->Encuesta_Mes, newNode->Encuesta_Anio, newNode->Procesada);
	
	fopen_s(&EncuestaCSV, "Encuesta.CSV", "a");
	if (EncuestaCSV == NULL){
	    printf("Error al abrir el csv\n");
	    return;
	}
	fprintf(EncuestaCSV, "%lld,%s,%d,%d,%d\n", newNode->Encuesta_Id, newNode->Denominacion, newNode->Encuesta_Mes, newNode->Encuesta_Anio, newNode->Procesada);
	fclose(EncuestaCSV);
}

void leerCSVencuestas(Encuesta **head) {
	FILE * csv;
	char linea [80];
	char * token;
	char * campoCsv[5];
	fopen_s(&csv, "Encuesta.CSV", "r");
	if (csv == NULL){
	    printf("Error al abrir el csv\n");
	    return;
	}
	while (fgets(linea, sizeof(linea), csv) != NULL)
	{
	    linea[strcspn(linea, "\n")] = 0;
	    int i = 0;
	     token = strtok(linea, ",");
	      while (token != NULL && i < 5) {
	            campoCsv[i] = token; 
	            i++;
	            token = strtok(NULL, ","); 
	        }
	    Encuesta * newNode = (Encuesta*)malloc(sizeof(Encuesta));
	    newNode->Encuesta_Id = strtoll(campoCsv[0], NULL, 10);
	    strcpy(newNode->Denominacion, campoCsv[1]);
	    newNode->Encuesta_Mes = atoi(campoCsv[2]);
	    newNode->Encuesta_Anio = atoi(campoCsv[3]);
	    newNode->Procesada = atoi(campoCsv[4]);
	    apilar(newNode, head);
	}
	fclose(csv);
}

void ListaDeEncuestas(Encuesta **head) {
    if (pilavacia(*head) == 1)
        return;

    Encuesta *nodeTmp = NULL;
    nodeTmp = desapilar(head);
    ListaDeEncuestas(head);  

    static int primeraVez = 1;
    if (primeraVez) {
        puts("\n| ENCUESTAS EXISTENTES |");
        puts("===========================================================================");
        printf("| %-12s | %-30s | %-10s | %-10s |\n", 
               "ENCUESTA ID", "DENOMINACION", "FECHA", "PROCESADA");
        puts("===========================================================================");
        primeraVez = 0;
    }


    char fecha[10];
    snprintf(fecha, sizeof(fecha), "%02d/%d", nodeTmp->Encuesta_Mes, nodeTmp->Encuesta_Anio);


    printf("| %-12lld | %-30s | %-10s | %-10d |\n",
           nodeTmp->Encuesta_Id,
           nodeTmp->Denominacion,
           fecha,
           nodeTmp->Procesada);

    apilar(nodeTmp, head);  
}

void modificarEncuesta(Encuesta **head, long long id, FILE *listaModificada){
if (pilavacia(*head) == 1)
	{
		return;
	}
	if (id == 0)
	{
		char bufferCleaner; 
		char aux[60];
		printf("ingrese id de la encuesta \n");
		fgets(aux, sizeof(aux), stdin);
		aux[strcspn(aux, "\n")] = 0;
		id = strtoll(aux, NULL, 0);
	}
	Encuesta * nodeTmp = NULL;
	nodeTmp = desapilar(head);
	modificarEncuesta(head, id, listaModificada);
	
	if (id == nodeTmp->Encuesta_Id)
	{
		char bufferCleaner; 
		time_t currentTime = time(NULL);
		struct tm *monthYear = localtime(&currentTime);
		printf("Ingresar nombre de la encuesta\n");
		fgets(nodeTmp->Denominacion, sizeof(nodeTmp->Denominacion), stdin);
		nodeTmp->Denominacion[strcspn(nodeTmp->Denominacion, "\n")] = 0;
		nodeTmp->Encuesta_Anio = monthYear->tm_year + 1900;
		nodeTmp->Encuesta_Mes = monthYear->tm_mon + 1;
		printf("-----Encuesta modificada----- \n Denominacion: %s \n id: %lld \n fecha: %d/%d \n Estado de procesamiento: %d\n", nodeTmp->Denominacion, nodeTmp->Encuesta_Id, nodeTmp->Encuesta_Mes, nodeTmp->Encuesta_Anio, nodeTmp->Procesada);
	}
	fprintf(listaModificada, "%lld,%s,%d,%d,%d\n", nodeTmp->Encuesta_Id, nodeTmp->Denominacion, nodeTmp->Encuesta_Mes, nodeTmp->Encuesta_Anio, nodeTmp->Procesada);
	apilar(nodeTmp, head);
}

void borrarEncuesta(Encuesta **head, long long id, FILE *listaModificada, Pregunta **headPr, Respuesta **headRe) {
	char aux[60];
    if (pilavacia(*head) == 1) {
        return;
    }
    if (id == 0) {
        printf("Ingrese ID de la encuesta: \n");
        fgets(aux, sizeof(aux), stdin);
        aux[strcspn(aux, "\n")] = 0;
        id = strtoll(aux, NULL, 0);
    }

    Encuesta *nodeTmp = NULL;
    nodeTmp = desapilar(head); 

    borrarEncuesta(head, id, listaModificada, headPr, headRe); 

    if (id == nodeTmp->Encuesta_Id) {
        borrarPregunta(headPr, id, headRe, *head); 
        free(nodeTmp); 
		printf("Encuesta %lld borrada", id);
        return;
    }
    fprintf(listaModificada, "%lld,%s,%d,%d,%d\n", nodeTmp->Encuesta_Id, nodeTmp->Denominacion, nodeTmp->Encuesta_Mes, nodeTmp->Encuesta_Anio, nodeTmp->Procesada);
    apilar(nodeTmp, head);
}

	
void menuEncuestas(Encuesta **head, Pregunta **headPr, Respuesta **headRe) {
    int opcion = 10;
    char auxiliar[50];
    FILE *listaModificada = NULL;

    while (opcion != 0) {
        puts("\n=========== MENU DE ENCUESTAS ===========\n""1. Crear nueva encuesta\n""2. Listar encuestas\n""3. Modificar encuesta\n""4. Eliminar encuesta\n""0. Volver al menu principal\n""=========================================\n""Seleccione una opcion: "
);

        fgets(auxiliar, sizeof(auxiliar), stdin);
        opcion = atoi(auxiliar);
        printf("\n");

        switch (opcion) {
            case 1:
                puts(">>> Creando nueva encuesta...");
                crearEncuesta(head);
            break;

            case 2:
                puts(">>> Mostrando lista de encuestas...");
                ListaDeEncuestas(head);
            break;
                
            case 3:
                ListaDeEncuestas(head);
                puts(">>> Modificando encuesta...");
                remove("Encuesta.CSV");
                fopen_s(&listaModificada, "Encuesta.CSV", "a");
                if (listaModificada == NULL) {
                    puts("Error al abrir el archivo Encuesta.CSV.");
                    return;
                }
                modificarEncuesta(head, 0, listaModificada);
                fclose(listaModificada);
                break;
                
            case 4:
                ListaDeEncuestas(head);
                puts(">>> Eliminando encuesta...");
                remove("Encuesta.CSV");
                fopen_s(&listaModificada, "Encuesta.CSV", "a");
                if (listaModificada == NULL) {
                    puts("Error al abrir el archivo Encuesta.CSV.");
                    return;
                }
                borrarEncuesta(head, 0, listaModificada, headPr, headRe);
                fclose(listaModificada);
            break;

            case 0:
                puts(">>> Volviendo al menu principal...");
                break;

            default:
                puts(">>> Opcion invalida. Intente de nuevo.");
                break;
        }
    }
}
